**Docker** - средство упаковки, доставки и запуска приложений
У всех приложений единый интерфейс

Докер включает в себя 2 основных понятия:
*Имедж* - готовое к запуску приложение.
*Контейнер* - работающее приложение, созданное на базе имиджа.

Для контейнера образ является  ридонли системой, то есть он не может изменить имедж.

Докерхаб - реестр докер имеджей.

ИМЕДЖИ МОЖНО ЗАПУШИТЬ В ДОКЕРХАБ.

`Docker images` - глянуть, какие имиджи у нас есть локально
`Docker ps` - какие контейнеры сейчас запущены

`Docker build` - создать образ
`-t` - тег
Полная команда `docker build -t имя приложения .` - точка значит что из текущего каталога

Перед тем как упаковывать, нужно собрать Dockerfile.

Расшифровка записей в Dockerfile:

`FROM` - базовый образ, с которого мы начинаем сборку
Через двоеточие - тег

`RUN` - выполнить определённую команду, которая идёт после RUN
(Создать папку)

`WORKDIR` - переходим в этот каталог  и у нас начинается выполнение команд с этого текущего каталога

`COPY` - два параметра откуда-куда, первый - точка, значит, что передаём с нашей текущей машины, куда - в контейнер (указан путь)

`EXPOSE 8080` - пробросим порта 8080 (указывать в докерфайле, потому что контейнер изолирован)

`ENV` - Переменная окружения

`CMD` - команда, которая говорит что надо делать, когда запустим контейнер

`ENTRYPOINT` - как CMD, но в суд выполняется через Шелл-оболочку, а энтрипоинт - без этого шелла

После команды `build` докер сначала загружает Пайтон, потом образ убунту, потом добавляет наши слои

Имэдж ид - это хэш-сумма

`Docker run имя образа` - запустить докер имидж
`-d` - запустить контейнер в фоне
`--name` -  с каким именем запустить приложение
`—rm` - удалить контейнер после отработки
`-p` - порты. Указываем два: первый на нашей машине, через двоеточие - порт внутри докер контейнера, например -p 8080:8080
`-e` - переменная окружения
`-v` - примонтировать к контейнеру папку, указываем сначала абсолютный путь на хостовой машине:абсолютный путь внутри докер контейнера (из пункта COPY в докерфайле)

!Контейнер работает до тех пор пока работает приложение!

`Docker rm докер ид или имя контейнера` - удалить контейнер
`Docker rm $(docker ps -qa)` - удалить все контейнеры по докер ид

`Docker ps -aq` - вывести только ид контейнеров

`Docker stop докер ид или имя контейнера` - остановить контейнер

Если в проекте есть много зависимостей, создаём файлик requirments.txt
Если у нас питон, другой разработчик выполняет `pip install -r requirments.txt`
В докерфайл надо добавить 
`pip install —no-cache-dir -r requirments.txt`

`Docker volume ls` - посмотреть список примонтированных папок

`Docker volume create имя` - создать примонтированную папку
Если есть примонтированная папка, можно запустить её так:
`docker run — rm  p 8080:8080 - v имяпримонтированнойпапки:абсолютный путь внутри контейнера (команда COPY) имя нашего имиджа`

`Docker rmi имя имиджа` - удалит скачанный имидж
`Docker rmi $(docker images -q)` - список ид имеющихся имеджей без удалённых

`Docker-compose` - надстройка над докером

Делаем файл docker-compose.yaml
1. `Version` - Сначала указываем версию
2. `Volumes` - какие вольным хотим в ней использовать, если не укажем, докер их создаст
3. `Services` - сервисы, которые нужно развернуть 
4. Параметры:
    `build` - указываем билд
    `restart: always` (после рестарта виртуальной машины докер автоматически поднимет все контейнеры)
    `environment:` все переменные, которые нужны

Запустить докер-композ - `docker-compose up -d`

`Docker-compose down` - остановить все контейнеры

`Docker login` - залогиниться на докерхабе
`Docker push` - залить туда образ
`Docker build -t` имяпользователя/имяпроекта - Собрать образ для докерхаба

https://www.youtube.com/watch?v=QF4ZF857m44&ab_channel=%D0%90%D1%80%D1%82%D0%B5%D0%BC%D0%9C%D0%B0%D1%82%D1%8F%D1%88%D0%BE%D0%B2




